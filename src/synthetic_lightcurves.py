import numpy as np
from astropy import units as u
from astropy.timeseries import TimeSeries

"""
synthetic_lightcurves.py

Tools for generating and manipulating synthetic astronomical lightcurves,
including simulated DRW lightcurves and realistic cadence sampling for CRTS,
ASAS-SN, ZTF, and WISE.

Author: Mia Forsyiak, Aashay Pai
Created: 2025-06-01
"""

# WISE_TIMES defines the midpoints of WISE observation epochs in decimal years,
# spanning from the original WISE mission (2010) through the NEOWISE-R reactivation (2022).
# These are used to resample or interpolate simulated lightcurves onto realistic WISE cadence.
WISE_TIMES = np.array([2010.03942459, 2010.535315  , 2014.00380812, 2014.49969853,
       2014.99558894, 2015.49147935, 2015.98736973, 2016.48193976,
       2016.97647528, 2017.47230121, 2017.96819162, 2018.46408203,
       2018.95997244, 2019.45586285, 2019.95175326, 2020.4464206 ,
       2020.94095612, 2021.43668477, 2021.93257518, 2022.42846559])

def generate_drw(t = 7300, tau = 300, z = 0, mean = 0, SF_inf = 0.3):
    """
    Generate a synthetic AGN light curve using a Damped Random Walk (DRW) model.

    The DRW is commonly used to describe stochastic variability in AGN light curves. 
    This function simulates a light curve with a specified damping timescale, structure 
    function, and redshift.

    Parameters
    ----------
    t : int, optional
        number of time steps (days) to simulate. Default is 7300 (~20 years).
    
    tau : float, optional
        characteristic damping timescale of the DRW (in days). Default is 300.
    
    z : float, optional
    rRedshift of the source. Used to time-dilate the light curve. Default is 0.
    
    mean : float, optional
        mean magnitude of the light curve. Default is 0.
    
    SF_inf : float, optional
        asymptotic structure function amplitude (long-term variability scale). Default is 0.3.

    Returns
    -------
    t_drw : np.ndarray
        array of time values (in days) in the observed frame.
    
    m_drw : np.ndarray
        simulated magnitude values at each time step, following the DRW process.
    """

    t_drw = np.arange(t)

    N = len(t_drw)

    m_drw = np.zeros(N)
    m_drw[0] = np.random.normal(mean, SF_inf) 

    E = np.random.normal(0, 1, N) 

    t_obs = t_drw * (1. + z) / tau 

    for i in range (1, N):
        dt = t_obs[i] - t_obs[i - 1] 
        m_drw[i] = (m_drw[i - 1] - dt * (m_drw[i - 1] - mean) + np.sqrt(2) * SF_inf * E[i] * np.sqrt(dt)) 

    return t_drw, m_drw


def tophat(width): 
    """
    Generate a normalized top-hat kernel for convolution.

    Parameters
    ----------
    width : int
        width of the kernel (number of elements). Must be non-negative.
        - if width == 0, returns an array with a single value [1.0] (no smoothing).
        - if width < 0, raises a ValueError.

    Returns
    -------
    kern : ndarray
        a 1D array of length `width` with each element equal to 1/width, 
        or [1.0] if width == 0.
    
    Raises
    ------
    ValueError
        if `width` is negative.
    """
    if width<0:
        raise ValueError(f"Kernel width cannot be: {width}")
    elif width==0:
        return np.ones(1)
    
    y = np.ones(width)
    kern = y/width
    return kern

def generate_sim_lc(t = 7300, tau = 300, z = 0, mean = 0, SF_inf = 0.3, width = 0.5, lag = 0, time_start="2005-01-01T12:00:00"):
    """
    Generate synthetic optical and infrared lightcurves using a damped random walk (DRW) model 
    and top-hat convolution to simulate emission line or reprocessing lags.

    Parameters
    ----------
    t : int, optional
        number of time steps (days) in the simulation. Default is 7300 (20 years).
    
    tau : float, optional
        DRW damping timescale in days. Default is 300.
    
    z : float, optional
        redshift (currently unused but reserved for future cosmological time-dilation corrections). Default is 0.
    
    mean : float, optional
        mean magnitude of the DRW lightcurve. Default is 0.
    
    SF_inf : float, optional
        structure function amplitude (long-term variability) for DRW. Default is 0.3.
    
    width : float, optional
        width of the top-hat kernel (as a fraction of the lag) used for convolution. Default is 0.5.
    
    lag : float, optional
        lag in days to apply to the W1 and W2 lightcurves relative to the optical lightcurve. Default is 0.
    
    time_start : str or astropy.time.Time, optional
        start time of the simulated lightcurves. Default is "2005-01-01T12:00:00".

    Returns
    -------
    sim_optical_lc : astropy.timeseries.TimeSeries
        simulated optical lightcurve based on DRW variability.
    
    sim_w1_lc : astropy.timeseries.TimeSeries
        simulated WISE W1 lightcurve, generated by convolving the DRW curve with a top-hat kernel 
        and shifted by the specified lag.
    
    sim_w2_lc : astropy.timeseries.TimeSeries
        simulated WISE W2 lightcurve, similarly convolved and lagged.

    Notes
    -----
    - DRW generation is performed by `generate_drw()` (assumed to return time and magnitude arrays).
    - Convolution uses a normalized top-hat kernel of width `width * |lag| / median(dt)`.
    - Noise is added with fixed magnitude uncertainty of 0.1 mag.
    """
    t_sim, m_sim = generate_drw()

    kern_width = int(width*np.abs(lag)/np.nanmedian(np.diff(t_sim)))

    w1_tophat_kernel = tophat(kern_width)

    w2_tophat_kernel = tophat(kern_width)

    w1_sim = np.convolve(w1_tophat_kernel, m_sim, "same")

    w2_sim = np.convolve(w2_tophat_kernel, m_sim, "same")

    noise = np.full(t, 0.1)
    
    sim_optical_lc = TimeSeries(time_start=time_start, time_delta=1 * u.d, n_samples=t, 
                 data = {"mag": m_sim,"mag_err": noise})

    sim_w1_lc = TimeSeries(time_start=time_start, time_delta=1 * u.d, n_samples=t, 
                 data = {"mag": w1_sim,"mag_err": noise})
    sim_w1_lc['time'] += (lag*u.day)
    sim_w2_lc = TimeSeries(time_start=time_start, time_delta=1 * u.d, n_samples=t, 
                 data = {"mag": w2_sim,"mag_err": noise})
    sim_w2_lc['time'] += (lag*u.day)
    return sim_optical_lc, sim_w1_lc, sim_w2_lc 

def simulate_crts(times, base_year=2005):
    """
    Simulate the observational cadence of the CRTS survey (2005–2013).

    For each year in the CRTS operation period:
    - Select a 6–8 month observing season (180–240 days).
    - Simulate field revisits every 14–30 days.
    - Assume 4 observations per visit (e.g., within the same night).

    Parameters
    ----------
    times : ndarray
        array of time indices (in days) since `base_year`.

    base_year : int, optional
        the reference year from which time indices are computed. Default is 2005.

    Returns
    -------
    mask : ndarray of bool
        boolean array of same shape as `times`, where `True` indicates a simulated observation.
    """
    mask = np.zeros_like(times, dtype=bool)
    for year in range(2005, 2014):
        start = (year - base_year) * 365                        #for each year,
        season_length = np.random.choice([180, 240])            #6-8 month seasonal observing period,
        for day in np.arange(start, start + season_length, 
                            np.random.randint(14, 30)):        #revisit the same field every 2-4 weeks,
            for offset in range(4):                             #4 observations per visit
                mask[start + int(day) + offset] = True            
    return mask

def simulate_asassn(times, base_year=2005):
    """
    Simulate the observational cadence of the ASAS-SN survey (2012–2019).

    For each year:
    - Simulate a 200-day observing period.
    - Each night within that period has a 30% chance of being an observation night,
      simulating ~70% average observing efficiency due to weather, moon, etc.

    Parameters
    ----------
    times : ndarray
        array of time indices (in days) since `base_year`.

    base_year : int, optional
        the reference year from which time indices are computed. Default is 2005.

    Returns
    -------
    mask : ndarray of bool
        boolean array of same shape as `times`, where `True` indicates a simulated observation.
    """
    mask = np.zeros_like(times, dtype=bool)
    for year in range(2012, 2020):
        start = (year - base_year) * 365
        for day in range(start, start + 200):
            if np.random.rand() < 0.3:  # 70% nightly observing efficiency
                mask[day] = True
    return mask

def simulate_ztf(times, base_year=2005):
    """
    Simulate the observational cadence of the ZTF survey (2018–2024).

    For each year:
    - Simulate a 240-day observing season.
    - Assume observations occur every 3 nights.

    Parameters
    ----------
    times : ndarray
        array of time indices (in days) since `base_year`.

    base_year : int, optional
        the reference year from which time indices are computed. Default is 2005.

    Returns
    -------
    mask : ndarray of bool
        boolean array of same shape as `times`, where `True` indicates a simulated observation.
    """
    mask = np.zeros_like(times, dtype=bool)
    for year in range(2018, 2025):
        start = (year - base_year) * 365
        for day in np.arange(start, start + 240, 3):  # every 3 nights
            mask[int(day)] = True
    return mask

def cadence_mask(start_year=2005, end_year=2025):
    """
    Generate a combined observational cadence mask mimicking the union of CRTS, ASAS-SN, and ZTF surveys.

    This function simulates the time sampling of three major time-domain surveys over a 20-year period
    (2005–2025), then combines their individual observation masks into a single boolean mask array.
    The returned mask can be applied to synthetic lightcurves to simulate realistic survey cadences.
    
    Parameters
    ----------
    start_year : float, optional
        beginning of the lightcurve. Default is 2005.
    
    end_year : float, optional
        end year of the lightcurve. Default is 2025.
    Returns
    -------
    combined_mask : ndarray of bool
        boolean array of length 7300 (20 years of daily sampling) where `True` indicates a simulated
        observation by at least one survey (CRTS, ASAS-SN, or ZTF) on that day.

    Notes
    -----
    The individual survey simulations are as follows:

    - `simulate_crts`:
        * Active from 2005 to 2013.
        * Observes during a random 6–8 month season per year.
        * Revisits the same field every 14–30 days with 4 observations per visit.

    - `simulate_asassn`:
        * Active from 2012 to 2019.
        * Observes over a 200-day stretch per year.
        * Has ~30% nightly observing efficiency.

    - `simulate_ztf`:
        * Active from 2018 to 2024.
        * Observes every 3 nights for a 240-day period per year.
    """

    total_days = (end_year - start_year) * 365
    times = np.arange(total_days)  

    mask_crts = simulate_crts(times)
    mask_asassn = simulate_asassn(times)
    mask_ztf = simulate_ztf(times)

    combined_mask = mask_crts | mask_asassn | mask_ztf
    return combined_mask

def generate_noisy_lc(lag=None, synth_opt_lc_full=None, synth_w1_full=None, synth_w2_full=None, **kwargs):
    """
    Generate noisy lightcurves for optical, WISE W1, and WISE W2 bands.

    This function either:
    1. Accepts a lag and simulation parameters and generates synthetic lightcurves using `generate_sim_lc`.
    2. Accepts precomputed synthetic lightcurves directly.

    The lightcurves are processed to mimic observational cadence:
    - The optical lightcurve is masked using `cadence_mask` to simulate CRTS/ASAS-SN/ZTF-like cadence.
    - W1 and W2 lightcurves are sampled to match the cadence of WISE observations (`WISE_TIMES`), 
      scaled by an arbitrary amplitude, and perturbed with Gaussian noise.

    Parameters
    ----------
    lag : float, optional
        time lag between optical and IR lightcurves in days. Required if generating lightcurves from scratch.
    
    synth_opt_lc_full : TimeSeries, optional
        full synthetic optical lightcurve. Must be provided if not generating from `lag`.

    synth_w1_full : TimeSeries, optional
        full synthetic W1 lightcurve. Must be provided if not generating from `lag`.

    synth_w2_full : TimeSeries, optional
        full synthetic W2 lightcurve. Must be provided if not generating from `lag`.

    **kwargs : dict
        additional keyword arguments passed to `generate_sim_lc` (e.g., t, tau, z, mean, SF_inf, width, time_start).

    Returns
    -------
    synth_opt_lc : TimeSeries
        masked optical lightcurve matching typical survey cadence.

    synth_w1 : TimeSeries
        WISE W1 lightcurve resampled to WISE cadence, scaled in amplitude and with added Gaussian noise.

    synth_w2 : TimeSeries
        WISE W2 lightcurve resampled to WISE cadence, scaled in amplitude and with added Gaussian noise.

    Raises
    ------
    ValueError
        If neither `lag` nor all three input lightcurves are provided.
    """
    if lag is None and (synth_opt_lc_full is None or synth_w1_full is None or synth_w2_full is None):
        raise ValueError("Either 'lag' or all three lightcurves ('synth_opt_lc_full', 'synth_w1_full', 'synth_w2_full') must be provided.")
    # If lag is provided but lightcurves not, generate lightcurves
    if lag is not None and (synth_opt_lc_full is None or synth_w1_full is None or synth_w2_full is None):
        synth_opt_lc_full, synth_w1_full, synth_w2_full = generate_sim_lc(lag=lag, **kwargs)

    mask = cadence_mask()
    #mimic the cadence of CRTS/ASAS-SN/ZTF surveys
    synth_opt_lc = synth_opt_lc_full[mask]

    #mimic WISE W1 cadence
    w1_inds = np.argmin(np.abs(synth_w1_full['time'].to_value('decimalyear')[:, None]-WISE_TIMES[None, :]), axis=0)
    synth_w1 = synth_w1_full[w1_inds]
    #add arbitrary amplitude representative of data
    synth_w1['mag'] *= np.random.uniform(2, 8)
    #add gaussian noise
    synth_w1['mag']+=np.random.normal(loc=0, scale=0.1, size=np.size(synth_w1['mag']))

    #mimic WISE W2 cadence
    w2_inds = np.argmin(np.abs(synth_w2_full['time'].to_value('decimalyear')[:, None]-WISE_TIMES[None, :]), axis=0)
    synth_w2 = synth_w2_full[w2_inds]
    #add arbitrary amplitude representative of data
    synth_w2['mag'] *= np.random.uniform(2, 8)
    #add gaussian noise
    synth_w2['mag']+=np.random.normal(loc=0, scale=0.1, size=np.size(synth_w2['mag']))

    return synth_opt_lc, synth_w1, synth_w2

